<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
    Document   : dictionary.xsd
    Created on : 28 mai 2007, 21:14
    Author     : Gege
    Description:
        Purpose of XML Schema document follows.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" elementFormDefault="qualified">

    <xs:element name="scenario" type="scenarioType"/>
    
    <xs:complexType name="scenarioType">
        <xs:complexContent>
            <xs:extension base="doType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="finally" type="doType" minOccurs="0" maxOccurs="unbounded"/>
               </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="doType">
        <xs:complexContent>
                <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="pause" type="pauseType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="exit" type="exitType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="system" type="systemType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="semaphore" type="semaphoreType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sqlQuery" type="sqlQueryType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="if" type="ifType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="switch" type="switchType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="while" type="whileType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="try" type="tryType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveMessage" type="receiveMessageType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="log" type="logType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="stats" type="statsType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="goto" type="gotoType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="label" type="labelType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="for" type="forType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="function" type="functionType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="call" type="callType" minOccurs="0" maxOccurs="unbounded"/>
                    <!-- liste des methodes pour la pile aaa -->           

	<xs:element name="sendMessageDIAMETER" type="sendMessageDIAMETERType" minOccurs="0" maxOccurs="unbounded">
	    <xs:annotation>
	        <xs:appinfo>mixed [0,N]</xs:appinfo>
	        <xs:documentation>To send a message for the DIAMETER protocol.</xs:documentation>
	    </xs:annotation>
	</xs:element>
	
	<xs:element name="receiveMessageDIAMETER" type="receiveMessageDIAMETERType" minOccurs="0" maxOccurs="unbounded">
	    <xs:annotation>
	        <xs:appinfo>mixed [0,N]</xs:appinfo>
	        <xs:documentation>To wait until a message of the DIAMETER protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
	    </xs:annotation>
	</xs:element>
	
	<xs:element name="createProbeDIAMETER" type="createProbeDIAMETERType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start the probe to capture for the DIAMETER protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeProbeDIAMETER" type="removeProbeDIAMETERType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop the probe to capture for the DIAMETER protocol.</xs:documentation>
			</xs:annotation>
	</xs:element>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->
	
	<xs:element name="sendRequestAAA" type="sendRequestAAAType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="sendAnswerAAA" type="sendAnswerAAAType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="receiveRequestAAA" type="receiveRequestAAAType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="receiveAnswerAAA" type="receiveAnswerAAAType" minOccurs="0" maxOccurs="unbounded"/>



                    <!-- liste des methodes pour la pile sip -->   

	<xs:element name="sendMessageSIP" type="sendMessageSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To send a message for the SIP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="receiveMessageSIP" type="receiveMessageSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To wait until a message of the SIP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="createListenpointSIP" type="createListenpointSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start listening for the SIP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeListenpointSIP" type="removeListenpointSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop listening for the SIP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="createProbeSIP" type="createProbeSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start the probe to capture for the SIP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeProbeSIP" type="removeProbeSIPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop the probe to capture for the SIP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->
                 
	<xs:element name="openProviderSIP" type="openProviderSIPType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="closeProviderSIP" type="closeProviderSIPType" minOccurs="0" maxOccurs="unbounded"/>                    
	<xs:element name="sendRequestSIP" type="sendRequestSIPType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="sendResponseSIP" type="sendResponseSIPType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="receiveRequestSIP" type="receiveRequestSIPType" minOccurs="0" maxOccurs="unbounded"/>
	<xs:element name="receiveResponseSIP" type="receiveResponseSIPType" minOccurs="0" maxOccurs="unbounded"/>
                    

                    <!-- liste des methodes pour la pile rtp -->

	<xs:element name="sendMessageRTP" type="sendMessageRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To send a message for the RTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
		</xs:annotation>
	</xs:element>	
	<xs:element name="receiveMessageRTP" type="receiveMessageRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To wait until a message of the RTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="createListenpointRTP" type="createListenpointRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start listening for the RTP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeListenpointRTP" type="removeListenpointRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop listening for the RTP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="createProbeRTP" type="createProbeRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start the probe to capture for the RTP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeProbeRTP" type="removeProbeRTPType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop the probe to capture for the RTP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
			
	<xs:element name="sendMessageRTPFLOW" type="sendMessageRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To send a message for the RTPFLOW protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
		</xs:annotation>
	</xs:element>		
	<xs:element name="receiveMessageRTPFLOW" type="receiveMessageRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To wait until a message of the RTPFLOW protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="createListenpointRTPFLOW" type="createListenpointRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start listening for the RTPFLOW protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeListenpointRTPFLOW" type="removeListenpointRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop listening for the RTPFLOW protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>				
	<xs:element name="createProbeRTPFLOW" type="createProbeRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To start the probe to capture for the RTPFLOW protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="removeProbeRTPFLOW" type="removeProbeRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
		<xs:annotation>
			<xs:appinfo>mixed [0,N]</xs:appinfo>
			<xs:documentation>To stop the probe to capture for the RTP protocol.</xs:documentation>
		</xs:annotation>
	</xs:element>
	

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

	<xs:element name="openConnectionRTP" type="openConnectionRTPType" minOccurs="0" maxOccurs="unbounded"/>                                    
	<xs:element name="closeConnectionRTP" type="closeConnectionRTPType" minOccurs="0" maxOccurs="unbounded"/>                        
	<xs:element name="sendPacketRTP" type="sendPacketRTPType" minOccurs="0" maxOccurs="unbounded"/>                                    
	<xs:element name="receivePacketRTP" type="receivePacketRTPType" minOccurs="0" maxOccurs="unbounded"/>                        


                    <!-- liste des methodes pour la pile http -->
<!-- deprecated part -->
<xs:element name="openConnectionHTTP" type="openConnectionHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeConnectionHTTP" type="closeConnectionHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendRequestHTTP" type="sendRequestHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendResponseHTTP" type="sendResponseHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveRequestHTTP" type="receiveRequestHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveResponseHTTP" type="receiveResponseHTTPType" minOccurs="0" maxOccurs="unbounded"/>
<!-- deprecated part -->

<xs:element name="openChannelHTTP" type="openChannelHTTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the HTTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelHTTP" type="closeChannelHTTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the HTTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageHTTP" type="sendMessageHTTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the HTTP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageHTTP" type="receiveMessageHTTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the HTTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>
                    <!-- liste des methodes pour la pile tcp -->

<!-- deprecated part -->
<xs:element name="openConnectionTCP" type="openConnectionTCPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeConnectionTCP" type="closeConnectionTCPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendDataTCP" type="sendDataTCPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveDataTCP" type="receiveDataTCPType" minOccurs="0" maxOccurs="unbounded"/>
<!-- deprecated part -->

<xs:element name="openChannelTCP" type="openChannelTCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the TCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="closeChannelTCP" type="closeChannelTCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the TCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="sendMessageTCP" type="sendMessageTCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the TCP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageTCP" type="receiveMessageTCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the TCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointTCP" type="createListenpointTCPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="removeListenpointTCP" type="removeListenpointTCPType" minOccurs="0" maxOccurs="unbounded"/>
                    <!-- liste des methodes pour la pile udp -->
<!-- deprecated part -->
<xs:element name="openSocketUDP" type="openSocketUDPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeSocketUDP" type="closeSocketUDPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendDataUDP" type="sendDataUDPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveDataUDP" type="receiveDataUDPType" minOccurs="0" maxOccurs="unbounded"/>
<!-- deprecated part -->

<xs:element name="createListenpointUDP" type="createListenpointUDPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the UDP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="removeListenpointUDP" type="removeListenpointUDPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the UDP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="sendMessageUDP" type="sendMessageUDPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the UDP protocol a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageUDP" type="receiveMessageUDPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the UDP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                    <!-- liste des methodes pour la pile sctp -->

<!-- deprecated part -->
<xs:element name="openConnectionSCTP" type="openConnectionSCTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeConnectionSCTP" type="closeConnectionSCTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendDataSCTP" type="sendDataSCTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveDataSCTP" type="receiveDataSCTPType" minOccurs="0" maxOccurs="unbounded"/>
<!-- deprecated part -->

<xs:element name="openChannelSCTP" type="openChannelSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the SCTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="closeChannelSCTP" type="closeChannelSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the SCTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="createListenpointSCTP" type="createListenpointSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the SCTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="removeListenpointSCTP" type="removeListenpointSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the SCTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="sendMessageSCTP" type="sendMessageSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the SCTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageSCTP" type="receiveMessageSCTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the SCTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>
                    <!-- liste des methodes pour la pile Radius -->
<!-- Deprecated part -->
<xs:element name="openSocketRadius" type="openSocketRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeSocketRadius" type="closeSocketRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendRequestRadius" type="sendRequestRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveRequestRadius" type="receiveRequestRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendResponseRadius" type="sendResponseRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveResponseRadius" type="receiveResponseRadiusType" minOccurs="0" maxOccurs="unbounded"/>
<!-- Deprecated part -->

<xs:element name="createListenpointRADIUS" type="createListenpointRADIUSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the RADIUS protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="removeListenpointRADIUS" type="removeListenpointRADIUSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the RADIUS protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageRADIUS" type="sendMessageRADIUSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the RADIUS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageRADIUS" type="receiveMessageRADIUSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the RADIUS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                    <!-- liste des methodes pour la pile smtp -->
<!-- deprecated part -->
<xs:element name="openSessionSMTP" type="openSessionSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeSessionSMTP" type="closeSessionSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendRequestSMTP" type="sendRequestSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendResponseSMTP" type="sendResponseSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveRequestSMTP" type="receiveRequestSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveResponseSMTP" type="receiveResponseSMTPType" minOccurs="0" maxOccurs="unbounded"/>
<!-- deprecated part -->

<xs:element name="openChannelSMTP" type="openChannelSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the SMTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="closeChannelSMTP" type="closeChannelSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the SMTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="createListenpointSMTP" type="createListenpointSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the SMTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="removeListenpointSMTP" type="removeListenpointSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the SMTP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="sendMessageSMTP" type="sendMessageSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the SMTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageSMTP" type="receiveMessageSMTPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the SMTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>
                    <!-- liste des methodes pour la pile rtsp -->
<xs:element name="openChannelRTSP" type="openChannelRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the RTSP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelRTSP" type="closeChannelRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the RTSP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointRTSP" type="createListenpointRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the RTSP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointRTSP" type="removeListenpointRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the RTSP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageRTSP" type="sendMessageRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the RTSP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageRTSP" type="receiveMessageRTSPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the RTSP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                  

                    <!-- liste des methodes pour la pile imap -->
<xs:element name="openChannelIMAP" type="openChannelIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the IMAP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelIMAP" type="closeChannelIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the IMAP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointIMAP" type="createListenpointIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the IMAP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointIMAP" type="removeListenpointIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the IMAP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageIMAP" type="sendMessageIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the IMAP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageIMAP" type="receiveMessageIMAPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the IMAP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                    <!-- liste des methodes pour la pile POP -->
<xs:element name="openChannelPOP" type="openChannelPOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the POP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelPOP" type="closeChannelPOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the POP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointPOP" type="createListenpointPOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the POP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointPOP" type="removeListenpointPOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the POP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessagePOP" type="sendMessagePOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the POP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessagePOP" type="receiveMessagePOPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the POP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                    <!-- liste des methodes pour la pile SMPP -->
<xs:element name="openChannelSMPP" type="openChannelSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the SMPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelSMPP" type="closeChannelSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the SMPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointSMPP" type="createListenpointSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the SMPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointSMPP" type="removeListenpointSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the SMPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageSMPP" type="sendMessageSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the SMPP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageSMPP" type="receiveMessageSMPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the SMPP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>


                    <!-- liste des methodes pour la pile UCP -->
<xs:element name="openChannelUCP" type="openChannelUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the UCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelUCP" type="closeChannelUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the UCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointUCP" type="createListenpointUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the UCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointUCP" type="removeListenpointUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the UCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageUCP" type="sendMessageUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the UCP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageUCP" type="receiveMessageUCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the UCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>


                    <!-- liste des methodes pour la pile SIGTRAN -->
<xs:element name="openChannelSIGTRAN" type="openChannelSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="closeChannelSIGTRAN" type="closeChannelSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="createListenpointSIGTRAN" type="createListenpointSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="removeListenpointSIGTRAN" type="removeListenpointSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="sendMessageSIGTRAN" type="sendMessageSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="receiveMessageSIGTRAN" type="receiveMessageSIGTRANType" minOccurs="0" maxOccurs="unbounded"/>

                    <!-- liste des methodes pour la pile tls -->

<xs:element name="openChannelTLS" type="openChannelTLSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the TLS protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="closeChannelTLS" type="closeChannelTLSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the TLS protocol.</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="sendMessageTLS" type="sendMessageTLSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the TLS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
    </xs:annotation>
</xs:element>
<xs:element name="receiveMessageTLS" type="receiveMessageTLSType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the TLS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointTLS" type="createListenpointTLSType" minOccurs="0" maxOccurs="unbounded"/>
<xs:element name="removeListenpointTLS" type="removeListenpointTLSType" minOccurs="0" maxOccurs="unbounded"/>
                    <!-- liste des methodes pour la pile h248 -->
<xs:element name="openChannelH248" type="openChannelH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the H248 protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelH248" type="closeChannelH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the H248 protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointH248" type="createListenpointH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the H248 protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointH248" type="removeListenpointH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the H248 protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageH248" type="sendMessageH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the H248 protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageH248" type="receiveMessageH248Type" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the H248 protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                    <!-- liste des methodes pour la pile pcp -->
<xs:element name="openChannelPCP" type="openChannelPCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the PCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelPCP" type="closeChannelPCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the PCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointPCP" type="createListenpointPCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the PCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointPCP" type="removeListenpointPCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the PCP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessagePCP" type="sendMessagePCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the PCP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessagePCP" type="receiveMessagePCPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the PCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                  

                    <!-- liste des methodes pour la pile msrp -->
<xs:element name="openChannelMSRP" type="openChannelMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the MSRP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelMSRP" type="closeChannelMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the MSRP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointMSRP" type="createListenpointMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the MSRP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointMSRP" type="removeListenpointMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the MSRP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageMSRP" type="sendMessageMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the MSRP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageMSRP" type="receiveMessageMSRPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the MSRP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>

                  

                    <!-- liste des methodes pour la pile GTPP -->
<xs:element name="openChannelGTPP" type="openChannelGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To open a channel for the GTPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="closeChannelGTPP" type="closeChannelGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To close a channel for the GTPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="createListenpointGTPP" type="createListenpointGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the GTPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointGTPP" type="removeListenpointGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the GTPP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageGTPP" type="sendMessageGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the GTPP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageGTPP" type="receiveMessageGTPPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the GTPP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>


                    <!-- liste des methodes pour la pile SNMP -->
<xs:element name="createListenpointSNMP" type="createListenpointSNMPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To start listening for the SNMP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="removeListenpointSNMP" type="removeListenpointSNMPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To stop listening for the SNMP protocol.</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="sendMessageSNMP" type="sendMessageSNMPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To send a message for the SNMP protocol using a channel or with the transactionId (user defined).</xs:documentation>
    </xs:annotation>
</xs:element>

<xs:element name="receiveMessageSNMP" type="receiveMessageSNMPType" minOccurs="0" maxOccurs="unbounded">
    <xs:annotation>
        <xs:appinfo>mixed [0,N]</xs:appinfo>
        <xs:documentation>To wait until a message of the SNMP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
    </xs:annotation>
</xs:element>


                    <!-- liste des methodes pour la pile mgcp -->

					<xs:element name="sendMessageMGCP" type="sendMessageMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To send a message for the MGCP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="receiveMessageMGCP" type="receiveMessageMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To wait until a message of the MGCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="createListenpointMGCP" type="createListenpointMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start listening for the MGCP protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="removeListenpointMGCP" type="removeListenpointMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop listening for the MGCP protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="createProbeMGCP" type="createProbeMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start the probe to capture for the MGCP protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="removeProbeMGCP" type="removeProbeMGCPType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop the probe to capture for the MGCP protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
                    <!-- liste des methodes pour la pile STUN -->

					<xs:element name="sendMessageSTUN" type="sendMessageSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To send a message for the STUN protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="receiveMessageSTUN" type="receiveMessageSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To wait until a message of the STUN protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="createListenpointSTUN" type="createListenpointSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start listening for the STUN protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="removeListenpointSTUN" type="removeListenpointSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop listening for the STUN protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="createProbeSTUN" type="createProbeSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start the probe to capture for the STUN protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="removeProbeSTUN" type="removeProbeSTUNType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop the probe to capture for the STUN protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
                    <!-- liste des methodes pour la pile H225CS -->

					<xs:element name="sendMessageH225CS" type="sendMessageH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To send a message for the H225CS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="receiveMessageH225CS" type="receiveMessageH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To wait until a message of the H225CS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="openChannelH225CS" type="openChannelH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start listening for the H225CS protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="closeChannelH225CS" type="closeChannelH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop listening for the H225CS protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="createProbeH225CS" type="createProbeH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To start the probe to capture for the H225CS protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="removeProbeH225CS" type="removeProbeH225CSType" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:appinfo>mixed [0,N]</xs:appinfo>
							<xs:documentation>To stop the probe to capture for the H225CS protocol.</xs:documentation>
						</xs:annotation>
					</xs:element>
               </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    
    <xs:complexType name="operationType">
        <xs:attribute name="name" type="xs:string" use="optional">    
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Generic: The operation name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="description" type="xs:string" use="optional">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Generic: The operation description (just a comment)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="state" type="xs:string" use="optional">    
			<xs:annotation>
				<xs:appinfo>Boolean</xs:appinfo>
				<xs:documentation>Generic: A flag to run or not the operation (equivalent to put the operation in comment code)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
    </xs:complexType>

    <xs:complexType name="operationTypeSimple">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
            <xs:attribute name="name" type="xs:string" use="optional">    
    			<xs:annotation>
    				<xs:appinfo>String</xs:appinfo>
    				<xs:documentation>Generic: The operation name</xs:documentation>
    			</xs:annotation>
    		</xs:attribute>
            <xs:attribute name="description" type="xs:string" use="optional">
    			<xs:annotation>
    				<xs:appinfo>String</xs:appinfo>
    				<xs:documentation>Generic: The operation description (just a comment)</xs:documentation>
    			</xs:annotation>
    		</xs:attribute>
            <xs:attribute name="state" type="xs:string" use="optional">    
    			<xs:annotation>
    				<xs:appinfo>Boolean</xs:appinfo>
    				<xs:documentation>Generic: A flag to run or not the operation (equivalent to put the operation in comment code)</xs:documentation>
    			</xs:annotation>
    		</xs:attribute>
            </xs:extension>
      	</xs:simpleContent>
    </xs:complexType>

<!--                                                                                       pause -->
    <xs:complexType name="pauseType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="seconds" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Float</xs:appinfo>
        				<xs:documentation>Pause duration in seconds</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="milliseconds" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Integer</xs:appinfo>
        				<xs:documentation>Pause duration in milliseconds</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    
<!--                                                                                        goto -->
    <xs:complexType name="gotoType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="label" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Target label name</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       label -->
    <xs:complexType name="labelType">
        <xs:complexContent>
            <xs:extension base="operationType">
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       exit -->
    <xs:complexType name="exitType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="failed" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Boolean</xs:appinfo>
        				<xs:documentation>Failed status: if true, the test will end as a failure, il false, as a success</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                   semaphore -->
    <xs:complexType name="semaphoreType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="action" type="semaphoreActionType" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Action to do on this semaphore: notify or wait</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" default="30">
        			<xs:annotation>
        				<xs:appinfo>Float</xs:appinfo>
        				<xs:documentation>Timeout value in seconds of wait actions</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="permits" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Integer</xs:appinfo>
        				<xs:documentation>Number of permit to give or take</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="semaphoreActionType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="notify"/>
            <xs:enumeration value="wait"/>
        </xs:restriction>
    </xs:simpleType>

<!--                                                                                    sqlQuery -->
    <xs:complexType name="sqlQueryType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="query" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>SQL query</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                    function -->
    <!--xs:complexType name="functionType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="params"   type="xs:string" use="required" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType-->

<!--                                                                                      system -->
    <xs:complexType name="systemType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="command" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>System (shell or dos) command</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                          if -->
    <xs:complexType name="ifType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:all>
                    <xs:element name="condition" type="conditionType"/>
                    <xs:element name="then" type="doType" minOccurs="0"/>
                    <xs:element name="else" type="doType" minOccurs="0"/>
                </xs:all>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="conditionType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                                          while -->
    <xs:complexType name="whileType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="condition" type="conditionType"/>
                    <xs:element name="do" type="doType"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                          try/finally -->
    <xs:complexType name="tryType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="do" type="doType" minOccurs="0"/>
                    <xs:element name="finally" type="doType" minOccurs="0"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                                          while -->
    <xs:complexType name="switchType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="case" type="caseType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="default" type="doType" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                <xs:attribute name="parameter" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Value that will be tested to execute the switch</xs:documentation>
        			</xs:annotation>
                </xs:attribute>

            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    
    <xs:complexType name="caseType">
        <xs:complexContent>
            <xs:extension base="doType">
                <xs:attribute name="equals" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>String the parameter will be compared against (equality)</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="matches" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>String the parameter will be compared against (regex matching)</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>    

	
<!--                                                                                       for -->
	<xs:complexType name="forType">
        <xs:complexContent>
            <xs:extension base="doType">    
				<xs:attribute name="index" type="xs:string" use="required">    
					<xs:annotation>
						<xs:appinfo>String (parameter name)</xs:appinfo>
						<xs:documentation>The name of the index parameter for the loop. This parameter is available for the user inside the loop.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="from" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The starting value for the loop index.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="to" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The ending value for the loop index.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="step" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The value to increase the index at each loop run (it could be a negative integer). The default value is 1.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
      	</xs:complexContent>
    </xs:complexType>


<!--                                                                                        test -->
    <xs:complexType name="testType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="parameter" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Tested parameter</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="condition" type="xs:string" use="required">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Name of the test operator (see #####)</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="value" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Value the parameter will be tested against</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="not" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Boolean</xs:appinfo>
        				<xs:documentation>If true, invert the test condition (default is false).</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                   parameter -->
    <xs:complexType name="parameterType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="operation" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Name of the operations that will be applied to the operands. You could use all the characters with an ASCI code less than 128 except the following characters &lt;&gt;"&amp;(): which interact with the XML syntax.</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            	<xs:attribute name="value" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 1</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            	<xs:attribute name="value2" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 2</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            	<xs:attribute name="value3" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 3</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            	<xs:attribute name="value4" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 4</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="value5" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 5</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="value6" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 6</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="value7" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Operand 7</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>            
    </xs:complexType>

<!--                                                                     generic receiveMessage -->
    <xs:complexType name="receiveMessageType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       log -->
    <xs:complexType name="logType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="level" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Level of the logs (0/1/2/3 or DEBUG/INFO/WARN/ERROR)</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>Destination logger for this log : Main or Scenario</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                      user statistics -->
    <xs:complexType name="statsType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="counter" type="statsCounterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="flow" type="statsFlowType" minOccurs="0" maxOccurs="unbounded"/>
                    <!-- DEPRECATED -->
                    <xs:element name="histogram" type="statsHistogramType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="value" type="statsHistogramType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="percent" type="statsPercentType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="text" type="statsTextType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="reset" type="statsResetType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <xs:complexType name="statsCounterType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="increase" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="decrease" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Name of the stats counter</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsFlowType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="increase" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="decrease" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Name of the stats counter</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsHistogramType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="newValue" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Name of the stats counter</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsPercentType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="incValue" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="incTotal" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Name of the stats counter</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsTextType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="newValue" type="statsAddType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Name of the stats counter</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string">
			<xs:annotation>
				<xs:appinfo>String</xs:appinfo>
				<xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc" type="xs:string">
			<xs:annotation>
				<xs:appinfo/>
				<xs:documentation>DEPRECATED</xs:documentation>
			</xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsAddType">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
                <xs:attribute name="value" type="xs:string" use="optional">
        			<xs:annotation>
        				<xs:appinfo>Float</xs:appinfo>
        				<xs:documentation>Value that will be added to the counter</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="seconds" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Float</xs:appinfo>
        				<xs:documentation>Timestamp in seconds at which the counter is added</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="milliseconds" type="xs:string">
        			<xs:annotation>
        				<xs:appinfo>Integer</xs:appinfo>
        				<xs:documentation>Timestamp in milliseconds at which the counter is added</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>    
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="statsResetType">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
                <xs:attribute name="path" type="xs:string" use="optional">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>The path in the stats tree to reach the counter to reset</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
                <xs:attribute name="name" type="xs:string" use="optional">
        			<xs:annotation>
        				<xs:appinfo>String</xs:appinfo>
        				<xs:documentation>The name of the counter to reset</xs:documentation>
        			</xs:annotation>
                </xs:attribute>
            </xs:extension>    
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                          function -->
<xs:complexType name="functionType">
    <xs:sequence>
        <xs:element name="input" type="inputFunctionType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="do" type="doType"/>
        <xs:element name="output" type="outputFunctionType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="file" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>file to import functions from</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the function</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<!--                                                                                          function -->
<xs:complexType name="callType">
    <xs:sequence>
        <xs:element name="input" type="inoutputCallType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="output" type="inoutputCallType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the function to call</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<!--                                                                                          arg -->
<xs:complexType name="inputFunctionType">
    <xs:attribute name="name" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the input argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>default value of the input argument, if not passed to the function. If not defined, the argument will be mandatory in call</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>type of the input argument, used to do some checks</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<!--                                                                                          arg -->
<xs:complexType name="outputFunctionType">
    <xs:attribute name="value" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>value of the output argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<xs:complexType name="inoutputCallType">
    <xs:attribute name="name" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string">
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>value of the argument that will be passed to the function</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<!--/xs:schema-->    
    
    
    
    
    
    
    
    
    
    
    
    
    

    <!--                                                                       START OF DIAMETER PROTOCOL -->


	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeDIAMETERType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                		<xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeDIAMETERType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                            sendMessage -->
    <xs:complexType name="sendMessageDIAMETERType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerAAAType"/>
                    <xs:element name="avp" type="avpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteURL" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request comes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
               			<xs:attribute name="request" type="xs:string">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>DEPRECATED : The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                            receiveMessage -->
    <xs:complexType name="receiveMessageDIAMETERType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
           			<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerAAAType">
        <xs:attribute name="request" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Boolean</xs:appinfo>
				<xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="command" type="xs:string" use="required">
    		<xs:annotation>
	    		<xs:appinfo>String</xs:appinfo>
				<xs:documentation>The command code or name (dictionary resolution).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="applicationId" type="xs:string" use="required">
    		<xs:annotation>
	    		<xs:appinfo>String</xs:appinfo>
				<xs:documentation>The application ID code or name (dictionary resolution).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="hopByHop" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Integer</xs:appinfo>
				<xs:documentation>The hop by hop identifier (transaction ID).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="endToEnd" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Integer</xs:appinfo>
				<xs:documentation>The end to end identifier (transaction ID).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="proxiable" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Boolean</xs:appinfo>
				<xs:documentation>The proxiable flag.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="error" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Boolean</xs:appinfo>
				<xs:documentation>The error flag.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
        <xs:attribute name="retransmit" type="xs:string">
    		<xs:annotation>
	    		<xs:appinfo>Boolean</xs:appinfo>
				<xs:documentation>The retransmit flag.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
    </xs:complexType>

<!--                                                                                         avp -->
    <xs:complexType name="avpType">
        <xs:sequence>
            <xs:element name="avp" type="avpType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="code" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="mandatory" type="xs:string"/>
        <xs:attribute name="private" type="xs:string"/>
        <xs:attribute name="vendorId" type="xs:string"/>
    </xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                              sendRequestAAA -->
    <xs:complexType name="sendRequestAAAType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerAAAType"/>
                    <xs:element name="avp" type="avpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="server" type="xs:string"/>
                <xs:attribute name="destScenario" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                               sendAnswerAAA -->
    <xs:complexType name="sendAnswerAAAType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerAAAType"/>
                    <xs:element name="avp" type="avpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <!--
                <xs:attribute name="server"       type="xs:string" />
                <xs:attribute name="destScenario" type="xs:string" />
                -->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
<!--                                                                           receiveRequestAAA -->
    <xs:complexType name="receiveRequestAAAType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="command" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                            receiveAnswerAAA -->
    <xs:complexType name="receiveAnswerAAAType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="timeout" type="xs:string"/>                
                <xs:attribute name="command" type="xs:string"/>
                <xs:attribute name="result" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         END OF DIAMETER PROTOCOL -->

    

<!--                                                                       START OF SIP PROTOCOL -->

	<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointSIPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
						<xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointSIPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeSIPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                		<xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeSIPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageSIPType">
		<xs:simpleContent>
			<xs:extension base="operationTypeSimple">
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageSIPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                              openProviderSIP -->
    <xs:complexType name="openProviderSIPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="providerName" type="xs:string" use="required"/>            
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="localPort" type="xs:string" use="required"/>
                <xs:attribute name="transport" type="xs:string"/>                
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              closeProviderSIP -->
    <xs:complexType name="closeProviderSIPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="providerName" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendRequestSIP -->
    <xs:complexType name="sendRequestSIPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">            
                <xs:attribute name="providerName" type="xs:string"/>                        
                <xs:attribute name="destScenario" type="xs:string"/>
                <xs:attribute name="delay" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>
                <xs:attribute name="remoteUrl" type="xs:string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                               sendResponseSIP -->
    <xs:complexType name="sendResponseSIPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="providerName" type="xs:string"/>                        
                <xs:attribute name="delay" type="xs:string"/>                
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>
                <xs:attribute name="remoteUrl" type="xs:string"/>                
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                           receiveRequestSIP -->
    <xs:complexType name="receiveRequestSIPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="providerName" type="xs:string"/>                            
                <xs:attribute name="method" type="xs:string"/>               
                <xs:attribute name="timeout" type="xs:string"/>                
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>            
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                            receiveResponseSIP -->
    <xs:complexType name="receiveResponseSIPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="providerName" type="xs:string"/>                                            
                <xs:attribute name="method" type="xs:string"/>
                <xs:attribute name="result" type="xs:string"/>
		<xs:attribute name="timeout" type="xs:string"/>                
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>            
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
<!--                                                                         END OF SIP PROTOCOL -->

    <!--                                                                         BEGIN OF RTP PROTOCOL -->


    <!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointRTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeRTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                		<xs:sequence>
                    			<xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
                		</xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:sequence>
                    			<xs:element name="flow" type="listenpointFlowType" minOccurs="0" maxOccurs="1"/>
                		</xs:sequence>
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<!--xs:attribute name="timeToWaitBlankFlow" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:appinfo>OBSOLETE</xs:appinfo>
						<xs:documentation>Time in seconds to detect a blank flow and return a msgRtpFlow. The default value is configurable(rtp.properties/scheduler.TIME_TO_WAIT_BLANK_FLOW)</xs:documentation>
					</xs:annotation>
				</xs:attribute-->
				<!--xs:attribute name="timeToWaitPeriodical" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:appinfo>OBSOLETE</xs:appinfo>						
						<xs:documentation>Time in seconds to return periodical msgRtpFlow since listenpoint creation. The default value is configurable(rtp.properties/scheduler.TIME_TO_WAIT_PERIODICAL)</xs:documentation>
					</xs:annotation>
				</xs:attribute-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="listenpointFlowType">
	        <xs:attribute name="endTimerNoPacket" type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow message is return by the tool when no packet is received during this timer value (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="endTimerSilentFlow" type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow is return by the tool when silent packets are received during this timer value (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="endTimerPeriodic" type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow message is return by the tool after this period timer (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="qosMeasurment" type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Do or don't do qos computing on messages received by this listenpoint. Must be false if ignoreReceivedMessages is true</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignoreReceivedMessages" type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Ignore content fo the received messages (memory performances).
The following path for setFromMessage will not work anymore :
header.payloadType
header.seqnum
header.timestamp
header.mark
payload.xxx
flow.payload.xxx
</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>


	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                <xs:sequence>
                    <xs:element name="flow" type="flowType" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


<!--                                                                                   flow -->
    <xs:complexType name="flowType">
        <xs:sequence>
  	    <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
	    <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="duration" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The duration of the RTP flow in seconds. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="packetNumber" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Integer</xs:appinfo>
			    <xs:documentation>The packet number of the RTP flow. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="synchronous" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Whether the flow sending is synchronous or not. The default value is true.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="bitRate" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The bit rate of the RTP flow. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="deltaTime" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The time between the sending of 2 RTP packets. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="deltaTimestamp" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The delta number of samples given by the RTP timestamp between 2 messages.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="jitterDelay" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The gigue delay of the RTP flow ie a random time delay added on each RTP packet timestamp. The default value is 0.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="packetLost" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The percentage of lost packet. The default value is 0.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
    </xs:complexType>

<!--                                                                                   packet -->
    <xs:complexType name="packetType">
        <xs:sequence>
  	    <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
	    <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerType">
        <xs:attribute name="channel" type="xs:string"/>
        <xs:attribute name="ssrc" type="xs:string" use="required"/>
        <xs:attribute name="payloadType" type="xs:string" use="required"/>
        <xs:attribute name="seqnum" type="xs:string"/>
        <xs:attribute name="timestamp" type="xs:string"/>
        <xs:attribute name="mark" type="xs:string"/>
    </xs:complexType>

<!--                                                                                   payload -->
    <xs:complexType name="payloadType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
        	<xs:attribute name="format" type="xs:string"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>


<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                           openConnectionRTP -->
    <xs:complexType name="openConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName" type="xs:string" use="required"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string" use="required"/>
		<xs:attribute name="remotePort" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           closeConnectionRTP -->
    <xs:complexType name="closeConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           sendPacketRTP -->
    <xs:complexType name="sendPacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
                    <!--xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="unbounded"/-->
                </xs:sequence>
                <xs:attribute name="sessionName" type="xs:string"/>
                <xs:attribute name="destScenario" type="xs:string"/>
                <!--xs:attribute name="payloadType" type="xs:string" /-->
                <!--xs:attribute name="ssrc" 	    type="xs:string" /-->
                <!--xs:attribute name="bandwith"    type="xs:string" /-->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           receivePacketRTP -->
    <xs:complexType name="receivePacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="sessionName" type="xs:string"/>
                <xs:attribute name="payloadType" type="xs:string"/>
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         END OF RTP PROTOCOL -->

    <!--                                                                       START OF HTTP PROTOCOL -->

<!--                                                                          openChannel -->
<xs:complexType name="openChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="localHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localPort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteURL" type="xs:string" use="required"/>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         closeChannel -->
<xs:complexType name="closeChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

<!--                                                                               sendMessage -->
<xs:complexType name="sendMessageHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteURL" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destScenario" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (scenario name)</xs:appinfo>
                    <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delay" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transactionId" type="xs:string">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                            receiveMessage -->
<xs:complexType name="receiveMessageHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openConnectionHTTP -->
<xs:complexType name="openConnectionHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="connectionName" type="xs:string" use="required"/>
            <xs:attribute name="localPort" type="xs:string"/>
            <xs:attribute name="localHost" type="xs:string"/>
            <xs:attribute name="remoteURL" type="xs:string" use="required"/>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         closeConnectionHTTP -->
<xs:complexType name="closeConnectionHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="connectionName" type="xs:string" use="required"/>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                              sendRequestHTTP -->
<xs:complexType name="sendRequestHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="connectionName" type="xs:string"/>
            <xs:attribute name="server" type="xs:string"/>
            <xs:attribute name="destScenario" type="xs:string"/>
            <xs:attribute name="delay" type="xs:string"/>
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                               sendResponseHTTP -->
<xs:complexType name="sendResponseHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="transactionId" type="xs:string" use="required"/>
            <xs:attribute name="delay" type="xs:string"/>
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                           receiveRequestHTTP -->
<xs:complexType name="receiveRequestHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="timeout" type="xs:string"/>
            <xs:attribute name="method" type="xs:string"/>
            <xs:attribute name="failedOnTimeout" type="xs:string"/>
            <xs:attribute name="failedOnReceive" type="xs:string"/>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                            receiveResponseHTTP -->
<xs:complexType name="receiveResponseHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="timeout" type="xs:string"/>
            <xs:attribute name="method" type="xs:string"/>
            <xs:attribute name="result" type="xs:string"/>
            <xs:attribute name="failedOnTimeout" type="xs:string"/>
            <xs:attribute name="failedOnReceive" type="xs:string"/>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         END OF HTTP PROTOCOL -->

    <!--                                                                      BEGIN OF TCP PROTOCOL -->


<!--                                                                          openChannel -->
	<xs:complexType name="openChannelTCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         closeChannel -->
	<xs:complexType name="closeChannelTCPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointTCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
    <!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointTCPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>
	
    <!--                                                                          sendMessageTCP -->
	<xs:complexType name="sendMessageTCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataTypeTCP" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageTCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataTypeTCP">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format" type="dataTypeTypeTCP"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataTypeTCP -->
    <xs:simpleType name="dataTypeTypeTCP">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text"/>
            <xs:enumeration value="binary"/>
        </xs:restriction>
    </xs:simpleType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openConnectionTCP -->
    <xs:complexType name="openConnectionTCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string" use="required"/>
                <xs:attribute name="remotePort" type="xs:string" use="required"/>                
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeConnectionTCP -->
    <xs:complexType name="closeConnectionTCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
            </xs:extension>

        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendDataTCP -->
    <xs:complexType name="sendDataTCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataTypeTCP" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveDataTCP -->
    <xs:complexType name="receiveDataTCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="connectionName" type="xs:string"/>                
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                        END OF TCP PROTOCOL -->

    <!--                                                                      BEGIN OF UDP PROTOCOL -->


<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointUDPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointUDPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageUDPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataUdpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="length" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The length of the message.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageUDPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataUdpType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format" type="dataUdpFormatType"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataUdpFormatType -->
    <xs:simpleType name="dataUdpFormatType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text"/>
            <xs:enumeration value="binary"/>
        </xs:restriction>
    </xs:simpleType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openSocketUDP -->
    <xs:complexType name="openSocketUDPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="socketName" type="xs:string" use="required"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>   
                <xs:attribute name="connected" type="xs:string"/>              
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeSocketUDP -->
    <xs:complexType name="closeSocketUDPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="socketName" type="xs:string" use="required"/>
            </xs:extension>

        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendDataUDP -->
    <xs:complexType name="sendDataUDPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataUdpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="socketName" type="xs:string" use="required"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>
                <xs:attribute name="length" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveDataUDP -->
    <xs:complexType name="receiveDataUDPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="socketName" type="xs:string"/>
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                        END OF UDP PROTOCOL -->

    <!--                                                                      BEGIN OF SCTP PROTOCOL -->

<!--                                                                          openChannel -->
	<xs:complexType name="openChannelSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="ostreams" type="xs:string"/>
                <xs:attribute name="instreams" type="xs:string"/>
                <xs:attribute name="attempts" type="xs:string"/>
                <xs:attribute name="timeo" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         closeChannel -->
	<xs:complexType name="closeChannelSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataSctpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageSCTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="stream" type="xs:string"/>
                <xs:attribute name="ppid" type="xs:string"/>
                <xs:attribute name="tsn" type="xs:string"/>
                <xs:attribute name="aid" type="xs:string"/>
                <xs:attribute name="sourceHost" type="xs:string"/>
                <xs:attribute name="sourcePort" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataSctpType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format" type="dataSctpFormatType"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataSctpFormatType -->
    <xs:simpleType name="dataSctpFormatType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text"/>
            <xs:enumeration value="binary"/>
        </xs:restriction>
    </xs:simpleType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openConnectionSCTP -->
    <xs:complexType name="openConnectionSCTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string" use="required"/>
                <xs:attribute name="remotePort" type="xs:string" use="required"/>   
                <xs:attribute name="ostreams" type="xs:string"/> 
                <xs:attribute name="instreams" type="xs:string"/>
                <xs:attribute name="attempts" type="xs:string"/>
                <xs:attribute name="timeo" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeConnectionSCTP -->
    <xs:complexType name="closeConnectionSCTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
            </xs:extension>

        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendDataSCTP -->
    <xs:complexType name="sendDataSCTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataSctpType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="connectionName" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveDataSCTP -->
    <xs:complexType name="receiveDataSCTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="connectionName" type="xs:string"/>
                <xs:attribute name="stream" type="xs:string"/>
                <xs:attribute name="ppid" type="xs:string"/>
                <xs:attribute name="tsn" type="xs:string"/>
                <xs:attribute name="aid" type="xs:string"/>
                <xs:attribute name="sourceHost" type="xs:string"/>
                <xs:attribute name="sourcePort" type="xs:string"/>
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                        END OF SCTP PROTOCOL -->

    <!--                                                                       START OF Radius PROTOCOL -->

<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointRADIUSType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="secret" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
    
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointRADIUSType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageRADIUSType">
		<xs:complexContent>
			<!--<xs:extension base="operationTypeSimple">-->
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerRadiusType"/>
                    <xs:element name="avp" type="avpRadiusType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="request" type="xs:string">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageRADIUSType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RADIUS.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
    
<!--                                                                                   header -->
    <xs:complexType name="headerRadiusType">
        <xs:attribute name="identifier" type="xs:string"/>
        <xs:attribute name="code" type="xs:string" use="required"/>
        <xs:attribute name="authenticator" type="xs:string"/>
    </xs:complexType>

<!--                                                                                         avp -->
    <xs:complexType name="avpRadiusType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="avp" type="vendorAvp" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="data" type="vendorData" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="code" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
        <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="vendorAvp">
        <xs:attribute name="code" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
        <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="vendorData">
        <xs:attribute name="value" type="xs:string" use="required"/>
    </xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openSocketRadius -->
    <xs:complexType name="openSocketRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="socketName" type="xs:string" use="required"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>   
                <xs:attribute name="secret" type="xs:string" use="required"/>   
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeSocketRadius -->
    <xs:complexType name="closeSocketRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="socketName" type="xs:string" use="required"/>
            </xs:extension>

        </xs:complexContent>
    </xs:complexType>
<!--                                                                              sendRequestRadius -->
    <xs:complexType name="sendRequestRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerRadiusType"/>
                    <xs:element name="avp" type="avpRadiusType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="socketName" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>
                <xs:attribute name="destScenario" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                               sendResponseRadius -->
    <xs:complexType name="sendResponseRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerRadiusType"/>
                    <xs:element name="avp" type="avpRadiusType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="socketName" type="xs:string" use="required"/>
                <xs:attribute name="remoteHost" type="xs:string"/>
                <xs:attribute name="remotePort" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
<!--                                                                           receiveRequestRadius -->
    <xs:complexType name="receiveRequestRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="socketName" type="xs:string"/>
                <xs:attribute name="type" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                            receiveResponseRadius -->
    <xs:complexType name="receiveResponseRadiusType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="timeout" type="xs:string"/>                
                <xs:attribute name="socketName" type="xs:string"/>
                <xs:attribute name="type" type="xs:string"/>
                <xs:attribute name="result" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         END OF Radius PROTOCOL -->

    <!--                                                                      BEGIN OF SMTP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointSMTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointSMTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageSMTPType">
		<xs:simpleContent>
			<xs:extension base="operationTypeSimple">
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>

<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageSMTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openConnectionSMTP -->
    <xs:complexType name="openSessionSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName" type="xs:string" use="required"/>
                <xs:attribute name="localPort" type="xs:string"/>
                <xs:attribute name="localHost" type="xs:string"/>
                <xs:attribute name="remoteHost" type="xs:string" use="required"/>
                <xs:attribute name="remotePort" type="xs:string" use="required"/>                
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeConnectionSMTP -->
    <xs:complexType name="closeSessionSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName" type="xs:string" use="required"/>
            </xs:extension>

        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendDataSMTP -->
    <xs:complexType name="sendRequestSMTPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">                     
                <xs:attribute name="sessionName" type="xs:string" use="required"/>     
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveDataSMTP -->
    <xs:complexType name="sendResponseSMTPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <!--xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="data" type="dataType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence-->     
                <xs:attribute name="transactionId" type="xs:string" use="required"/>   
                <!--xs:attribute name="commandName" type="xs:string"/-->   
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                sendDataSMTP -->
    <xs:complexType name="receiveRequestSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="sessionName" type="xs:string"/>                               
                <xs:attribute name="commandName" type="xs:string"/> 
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveDataSMTP -->
    <xs:complexType name="receiveResponseSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                 <xs:attribute name="sessionName" type="xs:string"/>                               
                <xs:attribute name="commandName" type="xs:string"/>     
                <xs:attribute name="replyCode" type="xs:string"/>                  
                <xs:attribute name="timeout" type="xs:string"/>
                <xs:attribute name="failedOnTimeout" type="xs:string"/>
                <xs:attribute name="failedOnReceive" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
<!-- END OF SMTP PROTOCOL -->

    <!--                                                                       START OF RTSP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelRTSPType">
        <xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessageRTSPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessageRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                         END OF RTSP PROTOCOL -->

    <!--                                                                      BEGIN OF IMAP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelIMAPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointIMAPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageIMAPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">                     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             END OF IMAP PROTOCOL -->

    <!--                                                                      BEGIN OF POP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelPOPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelPOPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointPOPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointPOPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessagePOPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">                     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessagePOPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             END OF POP PROTOCOL -->

    <!--                                                                      BEGIN OF SMPP PROTOCOL -->

<!--                                                                          openChannelSMPP -->
    <xs:complexType name="openChannelSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannelSMPP -->
    <xs:complexType name="closeChannelSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpointSMPP -->
    <xs:complexType name="createListenpointSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointSMPP -->
    <xs:complexType name="removeListenpointSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageSMPP -->
    <xs:complexType name="sendMessageSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerSMPPType" minOccurs="1" maxOccurs="1"/>
                    <xs:element name="attribute" type="attributeSMPPType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="tlv" type="tlvSMPPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerSMPPType">
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="id" type="xs:string"/>
        <xs:attribute name="length" type="xs:string"/>
        <xs:attribute name="status" type="xs:string"/>
        <xs:attribute name="sequence_number" type="xs:string" use="required"/>
    </xs:complexType>

<!--                                                                                attribute -->
    <xs:complexType name="attributeSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="attribute" type="attributeSMPPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="value" type="xs:string"/>
                <xs:attribute name="type" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                     tlv -->
    <xs:complexType name="tlvSMPPType">
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="length" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
        <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>

<!--                                                                             END OF SMPP PROTOCOL -->

    <!--                                                                      BEGIN OF UCP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelUCPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointUCPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerUCPType" minOccurs="1" maxOccurs="1"/>
                    <xs:element name="attribute" type="attributeUCPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerUCPType">
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="OT" type="xs:string"/>
        <xs:attribute name="LEN" type="xs:string"/>
        <xs:attribute name="TRN" type="xs:string" use="required"/>
        <xs:attribute name="MT" type="xs:string" use="required"/>
    </xs:complexType>



<!--                                                                                attribute -->
    <xs:complexType name="attributeUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="attribute" type="attributeUCPType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="xser" type="xserUCPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="value" type="xs:string"/>
                <xs:attribute name="encoding" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                xser -->
    <xs:complexType name="xserUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="type" type="xs:string" use="required"/>
                <xs:attribute name="length" type="xs:string" use="required"/>
                <xs:attribute name="value" type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             END OF UCP PROTOCOL -->

    	<!--                                                                       START OF PROTOCOL -->

	<!--                                                                          openChannelSIGTRAN -->
	<xs:complexType name="openChannelSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         closeChannelSIGTRAN -->
	<xs:complexType name="closeChannelSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                          createListenpointSIGTRAN -->
	<xs:complexType name="createListenpointSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeListenpointSIGTRAN -->
	<xs:complexType name="removeListenpointSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                          sendMessageSIGTRAN (protocol binary) -->
	<xs:complexType name="sendMessageSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="FVO" type="FVOType" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="TLV" type="TLVType"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         receiveMessageSIGTRAN -->
	<xs:complexType name="receiveMessageSIGTRANType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (SIGTRAN.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

  
  <!--                                                                                         	M3UA -->
  <xs:complexType name="TLVType">
      <xs:sequence>
          <xs:element name="header" type="headerTLVType"/>
          <xs:element name="parameter" type="parameterTLVType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string"/>
      <xs:attribute name="file" type="xs:string"/>
  </xs:complexType>
  <!--                                                                                         	headerM3UA -->
  <xs:complexType name="headerTLVType">
      <xs:attribute name="version" type="xs:string"/>
      <xs:attribute name="reserved" type="xs:string"/>
      <xs:attribute name="messageClass" type="xs:string" use="required"/>
      <xs:attribute name="messageType" type="xs:string" use="required"/>
      <xs:attribute name="messageLength" type="xs:string"/>
  </xs:complexType>
	<!--                                                                                     	parameterM3UA -->
  <xs:complexType name="parameterTLVType">
      <xs:sequence>
          <xs:choice>
              <xs:element name="parameter" type="parameterTLVType" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element name="field" type="fieldTLVType" minOccurs="0" maxOccurs="unbounded"/>
          </xs:choice>
      </xs:sequence>
      <xs:attribute name="tag" type="xs:string" use="required"/>
      <xs:attribute name="length" type="xs:string"/>
      <xs:attribute name="format" type="xs:string"/>
      <xs:attribute name="value" type="xs:string"/>
  </xs:complexType>
	<!--                                                                                    	fieldM3UA -->
  <xs:complexType name="fieldTLVType">
      <xs:attribute name="name" type="xs:string"/>
      <xs:attribute name="start" type="xs:string"/>
      <xs:attribute name="length" type="xs:string"/>
      <xs:attribute name="startBit" type="xs:string"/>
      <xs:attribute name="lengthBit" type="xs:string"/>
      <xs:attribute name="value" type="xs:string"/>
      <xs:attribute name="format" type="xs:string"/>
  </xs:complexType>
  
  <!--                                                                                 			FVO -->
  <xs:complexType name="FVOType">
      <xs:sequence minOccurs="1" maxOccurs="1">
      		<xs:element name="header" type="parameterFVOType" minOccurs="0" maxOccurs="1"/>
          	<xs:element name="parameter" type="parameterFVOType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string"/>
      <xs:attribute name="file" type="xs:string"/>
      <!--xs:attribute name="typeCode"    		type="xs:string" use="required" /-->
  </xs:complexType>
  
  <!--                                                                             				parameterFVO -->
  <xs:complexType name="parameterFVOType">
      <xs:sequence>
          <xs:element name="field" type="fieldFVOType" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string"/>
      <xs:attribute name="id" type="xs:string"/>
      <xs:attribute name="lengthIndicatorLength" type="xs:string"/>
      <xs:attribute name="pointerLength" type="xs:string"/>
      <xs:attribute name="type" type="xs:string"/>
  </xs:complexType>
  <!--                                                                          				fieldFVO -->
  <xs:complexType name="fieldFVOType">
      <xs:attribute name="name" type="xs:string"/>
      <xs:attribute name="start" type="xs:string"/>
      <xs:attribute name="length" type="xs:string"/>
      <xs:attribute name="startBit" type="xs:string"/>
      <xs:attribute name="lengthBit" type="xs:string"/>
      <xs:attribute name="value" type="xs:string" use="required"/>
      <xs:attribute name="format" type="xs:string"/>
  </xs:complexType> 
     
  <!--                                                                             END OF SIGTRAN PROTOCOL -->

    <!--                                                                      BEGIN OF TLS PROTOCOL -->

<!--                                                                          openChannel -->
	<xs:complexType name="openChannelTLSType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         closeChannelTLS -->
	<xs:complexType name="closeChannelTLSType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointTLSType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointTLSType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageTLSType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="data" type="dataTypeTLS" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageTLSType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
<!--                                                                                       data -->
    <xs:complexType name="dataTypeTLS">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format" type="dataTypeTypeTLS"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataTypeTLS -->
    <xs:simpleType name="dataTypeTypeTLS">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text"/>
            <xs:enumeration value="binary"/>
        </xs:restriction>
    </xs:simpleType>

<!--                                                                        END OF TLS PROTOCOL -->

    <!--                                                                      BEGIN OF H248 PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelH248Type">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelH248Type">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointH248Type">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointH248Type">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageH248Type">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">                     
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageH248Type">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             END OF H248 PROTOCOL -->

    <!--                                                                       START OF PCP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelPCPType">
        <xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="infranetConnection" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The url of the server th user want to connect to.(see pcp.properties for details)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="loginType" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The type of login the user want to use.(see pcp.properties for details)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelPCPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointPCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointPCPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessagePCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="1" maxOccurs="1">
                    <xs:element name="flist" type="xs:anyType"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessagePCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                         END OF PCP PROTOCOL -->

    <!--                                                                       START OF MSRP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelMSRPType">
        <xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessageMSRPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="transactionId" type="xs:string">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessageMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                         END OF MSRP PROTOCOL -->

    <!--                                                                      BEGIN OF GTPP PROTOCOL -->

<!--                                                                          openChannelGTPP -->
    <xs:complexType name="openChannelGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="required">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The channel transport.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannelGTPP -->
    <xs:complexType name="closeChannelGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpointGTPP -->
    <xs:complexType name="createListenpointGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointGTPP -->
    <xs:complexType name="removeListenpointGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageGTPP -->
    <xs:complexType name="sendMessageGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerGTPPType" minOccurs="1" maxOccurs="1"/>
                    <xs:element name="tlv" type="tlvGTPPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerGTPPType">
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="length" type="xs:string"/>
        <xs:attribute name="sequenceNumber" type="xs:string" use="required"/>
    </xs:complexType>

<!--                                                                                     tlv -->
    <xs:complexType name="tlvGTPPType">
        <xs:sequence>
            <xs:element name="attribute" type="attributeGTPPType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="tag" type="xs:string"/>
        <xs:attribute name="length" type="xs:string"/>
        <xs:attribute name="value" type="xs:string"/>
    </xs:complexType>

<!--                                                                                attribute -->
    <xs:complexType name="attributeGTPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="attribute" type="attributeGTPPType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:attribute name="value" type="xs:string"/>
                <xs:attribute name="type" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
<!--                                                                             END OF GTPP PROTOCOL -->

    <!--                                                                      BEGIN OF SNMP PROTOCOL -->

<!--                                                                          createListenpointSNMP -->
    <xs:complexType name="createListenpointSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointSNMP -->
    <xs:complexType name="removeListenpointSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageSNMP -->
    <xs:complexType name="sendMessageSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header" type="headerSNMPType" minOccurs="1" maxOccurs="1"/>
                    <xs:element name="pdu" type="pduSNMPType" minOccurs="1" maxOccurs="1"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>     
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerSNMPType">
        <xs:attribute name="version" type="xs:string" use="required"/>
        <xs:attribute name="community" type="xs:string" use="required"/>
    </xs:complexType>

<!--                                                                                     pdu -->
    <xs:complexType name="pduSNMPType">
        <xs:sequence>
            <xs:element name="variableBinding" type="variableBindingSNMPType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="type" type="xs:string"/>
        <xs:attribute name="requestId" type="xs:string"/>
        <xs:attribute name="errorStatus" type="xs:string"/>
        <xs:attribute name="errorIndex" type="xs:string"/>
        <xs:attribute name="nonRepeaters" type="xs:string"/>
        <xs:attribute name="maxRepetitions" type="xs:string"/>
        <xs:attribute name="enterprise" type="xs:string"/>
        <xs:attribute name="agentAddress" type="xs:string"/>
        <xs:attribute name="genericTrap" type="xs:string"/>
        <xs:attribute name="specificTrap" type="xs:string"/>
        <xs:attribute name="timestamp" type="xs:string"/>
    </xs:complexType>

<!--                                                                                variableBinding -->
    <xs:complexType name="variableBindingSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="value" type="xs:string"/>
                <xs:attribute name="type" type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
<!--                                                                             END OF SNMP PROTOCOL -->

    

<!--                                                                       START OF MGCP PROTOCOL -->

	<!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointMGCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
						<xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointMGCPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeMGCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeMGCPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageMGCPType">
		<xs:simpleContent>
			<xs:extension base="operationTypeSimple">
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteUrl" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageMGCPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>



    

<!--                                                                       START OF STUN PROTOCOL -->

	<!--                                                                          createListenpoint -->
<xs:complexType name="createListenpointSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="localHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localPort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenUDP" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenTCP" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenTLS" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transport" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                    <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>
	<!--                                                                         removeListenpoint -->
<xs:complexType name="removeListenpointSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

	<!--                                                                          createProbe -->
<xs:complexType name="createProbeSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="networkInterface" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="captureFilter" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="filename" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The filename to capture the network packets.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="regexFilter" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>
	<!--                                                                         removeProbe -->
<xs:complexType name="removeProbeSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

	<!--                                                                          sendMessage -->
<xs:complexType name="sendMessageSTUNType">
    <xs:complexContent>
			<!--<xs:extension base="operationTypeSimple">-->
        <xs:extension base="operationType">
            <xs:sequence>
                <xs:element name="header" type="headerSTUNType"/>
                <xs:element name="attribute" type="attributeSTUNType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="listenpoint" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remotePort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteUrl" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transport" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                    <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destScenario" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (scenario name)</xs:appinfo>
                    <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delay" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>


<xs:complexType name="headerSTUNType">
    <xs:attribute name="type" type="xs:string"/>
    <xs:attribute name="transactionID" type="xs:string"/>
   
</xs:complexType>

<!--                                                                                         avp -->
<xs:complexType name="attributeSTUNType">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="address" type="addressType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="changeRequest" type="changeRequestType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="errorCode" type="errorCodeType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="binary" type="binaryType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="text" type="textType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="messageIntegrity" type="messageIntegrityType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="unknownAttribute" type="unknownAttributeType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="xs:string"/>
</xs:complexType>

<xs:complexType name="addressType">
    <xs:attribute name="family" type="xs:string"/>
    <xs:attribute name="port" type="xs:string"/>
    <xs:attribute name="addressIP" type="xs:string"/>
</xs:complexType>

<xs:complexType name="changeRequestType">
    <xs:attribute name="changeIP" type="xs:string"/>
    <xs:attribute name="changePort" type="xs:string"/>
</xs:complexType>

<xs:complexType name="errorCodeType">
    <xs:attribute name="code" type="xs:string"/>
    <xs:attribute name="reasonPhrase" type="xs:string"/>
</xs:complexType>

<xs:complexType name="binaryType">
    <xs:attribute name="value" type="xs:string"/>
</xs:complexType>

<xs:complexType name="textType">
    <xs:attribute name="value" type="xs:string"/>
    
</xs:complexType>

<xs:complexType name="messageIntegrityType">
    <xs:attribute name="value" type="xs:string"/>
    <xs:attribute name="secret" type="xs:string" use="required"/>
</xs:complexType>

<xs:complexType name="unknownAttributeType">
    <xs:attribute name="type" type="xs:string"/>
</xs:complexType>

	<!--                                                                         receiveMessage -->
<xs:complexType name="receiveMessageSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenpoint" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>



    

<!--                                                                       START OF H225CS PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelH225CSType">
        <xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="required"/>
			</xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelH225CSType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

	<!--                                                                          createProbe -->
<xs:complexType name="createProbeH225CSType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="networkInterface" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="captureFilter" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="filename" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The filename to capture the network packets.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="regexFilter" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>
	<!--                                                                         removeProbe -->
<xs:complexType name="removeProbeH225CSType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

	<!--                                                                          sendMessage -->
<xs:complexType name="sendMessageH225CSType">
    <xs:complexContent>
			<!--<xs:extension base="operationTypeSimple">-->
        <xs:extension base="operationType">
            <xs:sequence>
                <xs:element name="q931" type="q931Type"/>
                <xs:element name="asn1" type="asn1Type"/>
            </xs:sequence>
            <xs:attribute name="listenpoint" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remotePort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteUrl" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transport" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                    <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destScenario" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (scenario name)</xs:appinfo>
                    <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delay" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>




<xs:complexType name="q931IntType">
    
</xs:complexType>

<xs:complexType name="elementType">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="field" type="fieldType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="identifier" type="xs:string"/>
</xs:complexType>

<xs:complexType name="fieldType">
    <xs:attribute name="name" type="xs:string"/>
    <xs:attribute name="lengthBit" type="xs:string"/>
    <xs:attribute name="type" type="xs:string"/>
    <xs:attribute name="value" type="xs:string"/>
</xs:complexType>


<xs:complexType name="headerQ931Type">
    <xs:attribute name="discriminator" type="xs:string"/>
    <xs:attribute name="callReference" type="xs:string"/>
    <xs:attribute name="callRefFlag" type="xs:string"/>
    <xs:attribute name="type" type="xs:string"/>
</xs:complexType>


<xs:complexType name="asn1Type">
    <xs:attribute name="dico" type="xs:string"/>
</xs:complexType>

<xs:complexType name="q931Type" mixed="true">
    <!--xs:complexContent>
        <xs:extension base="q931IntType"-->
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="headerQ931" type="headerQ931Type" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="elementType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="dico" type="xs:string"/>
        <!--/xs:extension>
    </xs:complexContent-->
</xs:complexType>




<!--                                                                                         avp -->




	<!--                                                                         receiveMessage -->
<xs:complexType name="receiveMessageH225CSType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter" type="parameterType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="test" type="testType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="and" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="or" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="not" type="conditionType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenpoint" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>



            
</xs:schema>
