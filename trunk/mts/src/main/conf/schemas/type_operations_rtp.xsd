<!--                                                                         BEGIN OF RTP PROTOCOL -->


    <!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointRTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeRTPType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                		<xs:sequence>
                    			<xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
					<xs:element name="header" type="headerType" minOccurs="0" maxOccurs="1"/>
	    				<xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>                    			
                		</xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteURL" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageRTPType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

    <!--                                                                          createListenpoint -->
	<xs:complexType name="createListenpointRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:sequence>
                    			<xs:element name="flow" type="listenpointFlowType" minOccurs="0" maxOccurs="1"/>
                		</xs:sequence>
				<xs:attribute name="localHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenUDP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTCP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenSCTP" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="localPortTLS" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<!--xs:attribute name="timeToWaitBlankFlow" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:appinfo>OBSOLETE</xs:appinfo>
						<xs:documentation>Time in seconds to detect a blank flow and return a msgRtpFlow. The default value is configurable(rtp.properties/scheduler.TIME_TO_WAIT_BLANK_FLOW)</xs:documentation>
					</xs:annotation>
				</xs:attribute-->
				<!--xs:attribute name="timeToWaitPeriodical" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:appinfo>OBSOLETE</xs:appinfo>						
						<xs:documentation>Time in seconds to return periodical msgRtpFlow since listenpoint creation. The default value is configurable(rtp.properties/scheduler.TIME_TO_WAIT_PERIODICAL)</xs:documentation>
					</xs:annotation>
				</xs:attribute-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="listenpointFlowType">
	        <xs:attribute name="endTimerNoPacket"	    type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow message is return by the tool when no packet is received during this timer value (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="endTimerSilentFlow"	    type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow is return by the tool when silent packets are received during this timer value (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="endTimerPeriodic"	    type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>A RTPflow message is return by the tool after this period timer (in seconds).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="qosMeasurment"	    type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Do or don't do qos computing on messages received by this listenpoint. Must be false if ignoreReceivedMessages is true</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ignoreReceivedMessages"	    type="xs:string" use="optional">
		    	<xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Ignore content fo the received messages (memory performances).
The following path for setFromMessage will not work anymore :
header.payloadType
header.seqnum
header.timestamp
header.mark
payload.xxx
flow.payload.xxx
</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<!--                                                                         removeListenpoint -->
	<xs:complexType name="removeListenpointRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>


	<!--                                                                          createProbe -->
	<xs:complexType name="createProbeRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
				<xs:attribute name="networkInterface" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="captureFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The filename to capture the network packets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="promiscuousMode" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         removeProbe -->
	<xs:complexType name="removeProbeRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType"/>
		</xs:complexContent>
	</xs:complexType>

<!--                                                                          sendMessage -->
	<xs:complexType name="sendMessageRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence>
                <xs:sequence>
                    <xs:element name="flow" type="flowType" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                </xs:sequence>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteHost" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remotePort" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Integer</xs:appinfo>
						<xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="remoteURL" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (url)</xs:appinfo>
						<xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transport" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
						<xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="destScenario" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String (scenario name)</xs:appinfo>
						<xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="delay" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--                                                                         receiveMessage -->
	<xs:complexType name="receiveMessageRTPFLOWType">
		<xs:complexContent>
			<xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
				<xs:attribute name="channel" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="listenpoint" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="probe" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The probe name to capture the message on.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="request" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="result" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>String</xs:appinfo>
						<xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="timeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Float</xs:appinfo>
						<xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnReceive" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
					<xs:annotation>
						<xs:appinfo>Boolean</xs:appinfo>
						<xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


<!--                                                                                   flow -->
    <xs:complexType name="flowType">
        <xs:sequence>
  	    <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
	    <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="duration"	    type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The duration of the RTP flow in seconds. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="packetNumber"	type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Integer</xs:appinfo>
			    <xs:documentation>The packet number of the RTP flow. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="synchronous" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Boolean</xs:appinfo>
			    <xs:documentation>Whether the flow sending is synchronous or not. The default value is true.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="bitRate"	    type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The bit rate of the RTP flow. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="deltaTime" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The time between the sending of 2 RTP packets. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="deltaTimestamp" type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The delta number of samples given by the RTP timestamp between 2 messages.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="jitterDelay"  	type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The gigue delay of the RTP flow ie a random time delay added on each RTP packet timestamp. The default value is 0.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
        <xs:attribute name="packetLost"  	type="xs:string" use="optional">
		    <xs:annotation>
			    <xs:appinfo>Float</xs:appinfo>
			    <xs:documentation>The percentage of lost packet. The default value is 0.</xs:documentation>
			</xs:annotation>
	    </xs:attribute>
    </xs:complexType>

<!--                                                                                   packet -->
    <xs:complexType name="packetType">
        <xs:sequence>
  	    <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
	    <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerType">
        <xs:attribute name="channel"	    type="xs:string" />
        <xs:attribute name="ssrc"	    type="xs:string" use="required" />
        <xs:attribute name="payloadType"    type="xs:string" use="required"/>
        <xs:attribute name="seqnum"  	    type="xs:string" />
        <xs:attribute name="timestamp"      type="xs:string" />
        <xs:attribute name="mark"           type="xs:string" />
    </xs:complexType>

<!--                                                                                   payload -->
    <xs:complexType name="payloadType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
        	<xs:attribute name="format"	    type="xs:string" />
        	<xs:attribute name="length"	    type="xs:string" />        	
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>


<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                           openConnectionRTP -->
    <xs:complexType name="openConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName"    type="xs:string" use="required"/>
                <xs:attribute name="localHost"      type="xs:string" />
                <xs:attribute name="localPort"      type="xs:string" />
                <xs:attribute name="remoteHost"     type="xs:string" use="required"/>
		<xs:attribute name="remotePort"     type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           closeConnectionRTP -->
    <xs:complexType name="closeConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName"    type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           sendPacketRTP -->
    <xs:complexType name="sendPacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
                    <!--xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="unbounded"/-->
                </xs:sequence>
                <xs:attribute name="sessionName"    type="xs:string" />
                <xs:attribute name="destScenario"   type="xs:string" />
                <!--xs:attribute name="payloadType" type="xs:string" /-->
                <!--xs:attribute name="ssrc" 	    type="xs:string" /-->
                <!--xs:attribute name="bandwith"    type="xs:string" /-->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           receivePacketRTP -->
    <xs:complexType name="receivePacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="sessionName"     type="xs:string" />
                <xs:attribute name="payloadType"     type="xs:string" />
                <xs:attribute name="timeout"         type="xs:string" />
                <xs:attribute name="failedOnTimeout" type="xs:string" />
                <xs:attribute name="failedOnReceive" type="xs:string" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         END OF RTP PROTOCOL -->
