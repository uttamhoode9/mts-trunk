<?xml version="1.0" encoding="UTF-8"?>

<scenario>

    <openChannelSCTP name="channel" localHost="[localHostSCTP]" localPort="[localPortSCTP]" remoteHost="[remoteHostSCTP]" remotePort="[remotePortSCTP]"  num_ostreams="30000" max_instreams="40000" />
       
    <receiveMessageSCTP type="INIT-ACK" timeout="1">
        <parameter name="[channelName]" operation="protocol.setFromMessage" value="channel.name" />    
        <parameter name="[temp]" operation="protocol.setFromMessage" value="data.binary" />
        <parameter name="[contents]" operation="protocol.setFromMessage" value="data.text" />
        <test parameter="[contents]" condition="string.equals" value="" />
    </receiveMessageSCTP>
    
    <sendMessageSCTP channel="channel">
        <data format="binary">h41:1 h441:1 b01000001:1 d0000065:1 65</data>
    </sendMessageSCTP>
    
   <receiveMessageSCTP/>

    <parameter name="[lastStream]" operation="protocol.setFromMessage" value="header.stream"/>
    <test parameter="[lastStream]" condition="number.equals" value="11222" />
    <!-- ssn is incremented automatically by the sctp stack if flag == 1 -->
    <parameter name="[lastSsn]" operation="protocol.setFromMessage" value="header.ssn"/>
    <test parameter="[lastSsn]" condition="number.equals" value="0"/>
    <parameter name="[lastPpid]" operation="protocol.setFromMessage" value="header.ppid"/>
    <test parameter="[lastPpid]" condition="number.equals" value="987654321" />
     <parameter name="[lastFlags]" operation="protocol.setFromMessage" value="header.flags"/>
    <test parameter="[lastFlags]" condition="number.equals" value="1" />
    <!-- context is always set to 0 by the sctp stack --> 
    <parameter name="[lastContext]" operation="protocol.setFromMessage" value="header.context"/>
    <test parameter="[lastContext]" condition="number.equals" value="0" />    <!-- tts is always set to 0 by the sctp stack --> 
    <parameter name="[lastTtl]" operation="protocol.setFromMessage" value="header.ttl"/>
    <test parameter="[lastTtl]" condition="number.equals" value="0" />
    <!-- ttl is choosen automatically by the sctp stack --> 
    <parameter name="[lastTsn]" operation="protocol.setFromMessage" value="header.tsn"/>
    <!--test parameter="[lastTsn]" condition="number.equals" value="0" /-->
     <!-- cumtls is managed automatically by the sctp stack -->
    <parameter name="[lastCumtsn]" operation="protocol.setFromMessage" value="header.cumtsn"/>
    <!--test parameter="[lastCumtsn]" condition="number.equals" value="0" /-->
    <!-- aid is choosen automatically by the sctp stack --> 
    <parameter name="[lastAid]" operation="protocol.setFromMessage" value="header.aid"/>
    <!--test parameter="[lastAid]" condition="number.equals" value="0" /-->

    <parameter name="[lastSourceHost]" operation="protocol.setFromMessage" value="header.sourceHost"/>
    <parameter name="[localHosts]" operation="system.ipaddress" value2="ipv4"/>
    <test parameter="[lastSourceHost(0)]" condition="string.equals" value="[localHosts(0)]" />
    <test parameter="[lastSourceHost(1)]" condition="string.equals" value="[localHosts(1)]" />
   <parameter name="[lastSourcePort]" operation="protocol.setFromMessage" value="header.sourcePort"/>
    <!--test parameter="[lastSourcePort]" condition="string.equals" value="[localPortSCTP]" /-->

    <parameter name="[contents]" operation="protocol.setFromMessage" value="data.text" />
    <test parameter="[contents]" condition="string.equals" value="AAAAA" />

    <finally>

        <closeChannelSCTP name="channel"/>

	      <receiveMessageSCTP type="ABORT-ACK" timeout="1">
             <parameter name="[connectionName]" operation="protocol.setFromMessage" value="channel.name" />    
             <parameter name="[temp]" operation="protocol.setFromMessage" value="data.binary" />
             <parameter name="[contents]" operation="protocol.setFromMessage" value="data.text" />
             <test parameter="[contents]" condition="string.equals" value="" />
        </receiveMessageSCTP>

    </finally>

</scenario>
