# If the parameter is set to "True", then the IMSLoader SIP stack automatically adds a CRLF characters 
# at the end of the Content block if present only.
# This parameter is useful with NSN SIP equipments (specially IMS RPF2 ones)
# [boolean] 
nsn.ADD_CRLF_CONTENT = false

# Sets the outbound proxy of the SIP Stack. The format for this string is "ipaddress:port/transport" 
# i.e. 129.1.22.333:5060/UDP. This property is optional. 
# type address (ie <host>:<port>/<TRANSPORT>)
# [string] 
javax.sip.OUTBOUND_PROXY = 172.16.21.26\:4060/UDP

# Time (in seconds) of life the messages and transactions and retransmission objects
# [float] 
MESSAGE_TIME_LIFE = 32

# Timeout duration (in seconds) for the receive operations
# [float] 
operations.RECEIVE_TIMEOUT = 32

# Flag to activate the automatic retransmission sending for messages
# if true then a retransmission messages are sent
# [boolean] 
retransmit.MANAGEMENT = true

# Flag to activate the retransmission filtering on messages receipt; 
# if true then a retransmission messages are not routed to the scenario
# they are ignored
# [boolean] 
retransmit.FILTERING = true

# Retransmission list of timers in seconds
# type list<float>
# [string] 
retransmit.TIMERS = 0.5, 1, 2, 4, 4, 4, 4, 4, 4, 4

# The transactionID is used internally to make the corresponding between requests and responses.
# The tool uses transaction for internal routing : it automatically routes a received response 
# to the scenario which has sent the corresponding request.
# This parameter is used to get the transactionID from the message given a list of paths (separated 
# by ',' character). The paths are defined with the setFromMessage operation and are of course 
# protocol dependant
# type list<string> (list of path keywords)
# [string] 
route.TRANSACTION_ID = header.CSeq,header.TopmostVia.Parameter.branch

# The tool automatically routes a received request to the scenario given in the "destScenario" parameter 
# of the send operation in the same testcase. In this case, the tool is simulating a client and server 
# at the same time.
# The messageID is used internally to make the corresponding between requests which are sent by 
# the tool and the same requests the tool has received 
# This parameter is used to get the messageID from the message given a list of paths (separated 
# by ',' character). The path are defined with the setFromMessage operation and are protocol of 
# course dependant
# type list<string> (list of path keywords)
# [string] 
route.MESSAGE_ID = header.CSeq,header.DialogId

# The tool routes a received request to the scenario given by its name. In this case, the tool is 
# simulating a pure server.
# This parameter is used to get the scenario name as mentioned in the test file from the message 
# given a list of paths (separated by ',' character). The path are defined with the setFromMessage 
# operation and are of course protocol dependant
# type list<string> (list of path keywords)
# [string] 
route.SCENARIO_NAME = listenpoint.localPort

# This ID is used to identify retransmissions. A message having the same retranmissionId as a previous one
# will be handled as a retransmission. If it is a request it will eventually lead to the retransmission of
# subsequent responses and the filtering of the message. If it is a response it might lead to the filtering
# of the message.
# type list<string> (list of path keywords)
# [string] 
route.RETRANSMISSION_ID = message.messageId,message.transactionId,firstline

# test use only
# [string] 
NB_ITERATION = 10000

# Default host for SIP endpoints
# [string] 
DEFAULT_HOST = 

# Default port for SIP endpoints
# [integer] 
DEFAULT_PORT = 

# Default transport for SIP endpoints; possible values are : udp/tcp/rfc
# type string udp|tcp|rfc
# [enumeration] udp|tcp|rfc 
DEFAULT_TRANSPORT = udp

# Retransmission management (use the transaction of the SIP stack) : true/false
# [boolean] 
gov.nist.javax.sip.RETRANS_MANAGEMENT = false

# Retransmission timer in milliseconds
# [integer] 
gov.nist.javax.sip.RETRANS_TIMER = 500

# Sets a user friendly name to identify the underlying stack implementation to the property 
# value i.e. NISTv1.2. The stack name property should contain no spaces. This property is mandatory.
# [string] 
javax.sip.STACK_NAME = IMSLoader

# Sets the fully qualified classpath to the application supplied Router object that determines how to 
# route messages when the stack cannot make a routing decision ( ie. non-sip URIs). In version 1.2
# of this specification, out of Dialog SIP URIs are routed by the Routing algorithm defined in RFC
# 3261 which is implemented internally by the stack provided that javax.sip.USE_ROUTER_FOR_ALL_URIS
# is set to false. In this case, the installed Router object is consulted for routing decisions 
# pertaining to non-SIP URIs. An application defined Router object must implement the 
# javax.sip.Router interface. This property is optional. 
# For OpenIMS core, you should use the following specific router path with the value 
# "gov.nist.javax.sip.stack.IMSRouter".
# This class route the request according the OUTBOUND_PROXY parameter ignoring the Route header 
# and the request URI information. 
# javax.sip.ROUTER_PATH =gov.nist.javax.sip.stack.DefaultRouter
# [string] 
javax.sip.ROUTER_PATH = gov.nist.javax.sip.stack.IMSRouter

# This configuration value informs the underlying implementation of supported extension methods that
# create new dialog's. This list must not include methods that are natively supported by this 
# specification such as INVITE, SUBSCRIBE and REFER. This configuration flag should only be used for 
# dialog creating extension methods, other extension methods that don't create dialogs can be used 
# using the method parameter on Request assuming the implementation understands the method. If more 
# than one method is supported in this property each extension should be seprated with a colon for 
# example "FOO:BAR". This property is optional. 
# type string (: separator)
# [string] 
javax.sip.EXTENSION_METHODS = 

# Deprecated v1.2. Applications can request retransmission alerts from the 
# ServerTransaction.enableRetransmissionAlerts(). 
# The default retransmission behaviour of this specification is dependent on the application core and 
# is defined as follows: 
# * User Agent Client: Retransmissions of ACK Requests are the responsibility of the application. 
#   All other retansmissions are handled by the SipProvider. 
# * User Agent Server: Retransmissions of 1xx, 2xx Responses are the responsibility of the application. 
#   All other retansmissions are handled by the SipProvider. 
# * Stateful Proxy: As stateful proxies have no Invite transactions all retransmissions are handled 
#   by the SipProvider. 
# * Stateless Proxy: As stateless proxies are not transactional all retransmissions are the 
#   responsibility of the application and will not be handled the SipProvider. 
# This filter can be viewed as a helper function for User Agents that can be set by an application to 
# prevent the application from handling retransmission of ACK Requests, 1xx and 2xx Responses for 
# INVITE transactions, i.e. the SipProvider will handle the retransmissions. This utility is useful 
# for hiding protocol retransmission semantics from higher level programming environments. The acceptable 
# values are ON/OFF. This property is optional, therefore if not supplied the default is OFF. 
# type boolean ON|OFF
# [enumeration] ON|OFF 
javax.sip.RETRANSMISSON_FILTER = OFF

# This property specifies the defined values 'ON' and 'OFF'. The default value is 'ON'. The default 
# behavior represents a common mode of stack operation and allows the construction of simple user 
# agents. This property is optional. This is summarized as: 
# * A dialog gets created on a dialog creating transaction. 
# * The first response having both a From and a To tag creates the transaction. 
# * The first 2xx response to the transaction will drive the dialog to the CONFIRMED state. 
# The ability to turn of dialog support is motivated by dialog free servers (such as proxy servers) 
# that do not want to pay the overhead of the dialog layer and user agents that may want to create 
# multiple dialogs for a single INVITE (as a result of forking by proxy servers). The following 
# behavior is defined when the configuration parameter is set to 'OFF'. 
# * The application is responsible to create the Dialog if desired. 
# * The application may create a Dialog and associate it with a response (provisional or final) of a dialog creating request.  
# type boolean ON|OFF
# [enumeration] ON|OFF 
javax.sip.AUTOMATIC_DIALOG_SUPPORT = OFF

# Comma separated list of events for which the implementation should expect forked SUBSCRIBE dialogs. 
# Each element of this list must have the syntax packagename.eventname This configuration parameter is 
# provided in order to support the following behavior ( defined in RFC 3265): Successful SUBSCRIBE 
# requests will normally receive only one 200-class response; however, due to forking, the subscription 
# may have been accepted by multiple nodes. The subscriber MUST therefore be prepared to receive NOTIFY 
# requests with "From:" tags which differ from the "To:" tag received in the SUBSCRIBE 200-class 
# response. If multiple NOTIFY messages are received in different dialogs in response to a single 
# SUBSCRIBE message, each dialog represents a different destination to which the SUBSCRIBE request was 
# forked. Each event package MUST specify whether forked SUBSCRIBE requests are allowed to install 
# multiple subscriptions.If such behavior is not allowed, the first potential dialog-establishing 
# message will create a dialog. All subsequent NOTIFY messages which correspond to the SUBSCRIBE 
# message (i.e., match "To","From", "From" header "tag" parameter, "Call-ID", "CSeq", "Event", and 
# "Event" header "id" parameter) but which do not match the dialog would be rejected with a 481 
# response. This property is optional.
# [string] 
javax.sip.FORKABLE_EVENTS = 

# Currently only TRACE (16) and DEBUG is meaningful. If this is set to 16 or above, then incoming 
# valid messages are logged in SERVER_LOG. If you set this to 32 and specify a DEBUG_LOG then vast 
# amounts of trace information will be dumped in to the specified DEBUG_LOG. The server log 
# accumulates the signaling trace. This can be viewed using the trace viewer tool . Please send 
# us both the server log and debug log when reporting non-obvious problems. You can also use the 
# strings DEBUG or INFO for level 32 and 16 respectively
# [integer] 
gov.nist.javax.sip.TRACE_LEVEL = 0

# Log valid incoming messages here. If this is left null AND the TRACE_LEVEL is above 16 then 
# the messages are printed to stdout. Otherwise messages are logged in a format that can later be 
# viewed using the trace viewer application which is located in the tools/tracesviewer directory. 
# type filename
# [string] 
gov.nist.javax.sip.SERVER_LOG = ../logs/sip-server.log

# Set true if you want to capture content into the log. Default is false. A bad idea to log 
# content if you are using SIP to push a lot of bytes through TCP
# [boolean] 
gov.nist.javax.sip.LOG_MESSAGE_CONTENT = true

# Where the debug log goes.
# type filename
# [string] 
gov.nist.javax.sip.DEBUG_LOG = ../logs/sip-debug.log

# Maximum size of content that a TCP connection can read. Must be at least 4K. Default is 
# "infinity" -- ie. no limit. This is to prevent DOS attacks launched by writing to a TCP 
# connection until the server chokes
# [string] 
gov.nist.javax.sip.MAX_MESSAGE_SIZE = -1

# Default value is true. Setting this to true makes the Stack close the server socket after 
# a Server Transaction goes to the TERMINATED state. This allows a server to protect against 
# TCP based Denial of Service attacks launched by clients (ie. initiate hundreds of client 
# transactions). If false (default action), the stack will keep the socket open so as to maximize 
# performance at the expense of Thread and memory resources - leaving itself open to DOS attacks.
# [boolean] 
gov.nist.javax.sip.CACHE_SERVER_CONNECTIONS = true

# Default value is true. Setting this to true makes the Stack close the server socket after a Client 
# Transaction goes to the TERMINATED state. This allows a client release any buffers threads and 
# socket connections associated with a client transaction after the transaction has terminated at 
# the expense of performance.
# [boolean] 
gov.nist.javax.sip.CACHE_CLIENT_CONNECTIONS = true

# Concurrency control for number of simultaneous active threads. If unspecificed, the default is 
# "infinity". This feature is useful if you are trying to build a container. 
# * If this is not specified, and the listener is re-entrant, each event delivered to the listener 
#   is run in the context of a new thread. 
# * If this is specified and the listener is re-entrant, then the stack will run the listener using 
#   a thread from the thread pool. This allows you to manage the level of concurrency to a fixed 
#   maximum. Threads are pre-allocated when the stack is instantiated. 
# * If this is specified and the listener is not re-entrant, then the stack will use the thread 
# pool thread from this pool to parse and manage the state machine but will run the listener in its 
# own thread.
# [integer] 
gov.nist.javax.sip.THREAD_POOL_SIZE = -1

# Set to true if the listener is re-entrant. If the listener is re-entrant then the stack manages a thread pool and synchronously calls the listener from the same thread which 
# ead the message. Multiple transactions may concurrently receive messages and this will result 
# n multiple threads being active in the listener at the same time. The listener has to be written 
# ith this in mind. If you want good performance on a multithreaded machine write your listener 
# o be re-entrant and set this property to be true. Default is false.
# [boolean] 
gov.nist.javax.sip.REENTRANT_LISTENER = true

# Max number of simultaneous TCP connections handled by stack.
# [integer] 
gov.nist.javax.sip.MAX_CONNECTIONS = -1

# Maximum size of server transaction table. The low water mark is 80% of the high water mark. 
# Requests are selectively dropped in the lowater mark to highwater mark range. Requests are 
# unconditionally accepted if the table is smaller than the low water mark. The default highwater 
# mark is 5000
# [integer] 
gov.nist.javax.sip.MAX_SERVER_TRANSACTIONS = 5000

# Max number of active client transactions before the caller blocks and waits for the number to 
# drop below a threshold. Default is unlimited, i.e. the caller never blocks and waits for a client 
# transaction to become available (i.e. it does its own resource management in the application).
# [integer] 
gov.nist.javax.sip.MAX_CLIENT_TRANSACTIONS = 5000

# If true then the listener will see the ACK for non-2xx responses for server transactions. 
# This is not standard behavior per RFC 3261 (INVITE server transaction state machine) but 
# this is a useful flag for testing. The TCK uses this flag for example.
# [boolean] 
gov.nist.javax.sip.PASS_INIVTE_NON2XX_ACK_TO_LISTENER = true

# Default is false. ACK Server Transaction is a Pseudo-transaction. If you want termination 
# notification on ACK transactions (so all server transactions can be handled uniformly in user 
# code during cleanup), then set this flag to true.
# [boolean] 
gov.nist.javax.sip.DELIVER_TERMINATED_EVENT_FOR_ACK = 

# This is relevant for incoming TCP connections to prevent starvation at the server. This defines 
# the timeout in milliseconds between successive reads after the first byte of a SIP message is read 
# by the stack. All the sip headers must be delivered in this interval and each successive buffer 
# must be of the content delivered in this interval. Default value is -1 (ie. the stack is wide open 
# to starvation attacks) and the client can be as slow as it wants to be. 
# type integer (in milliseconds)
# [integer] 
gov.nist.javax.sip.READ_TIMEOUT = 3600000

# (default is false) Automatically generate a getTimeOfDay timestamp for a retransmitted request 
# if the original request contained a timestamp. This is useful for profiling
# [boolean] 
gov.nist.javax.sip.AUTO_GENERATE_TIMESTAMP = 

# Defines how often the application intends to audit the SIP Stack about the health of its internal 
# threads (the property specifies the time in milliseconds between successive audits). The audit 
# allows the application to detect catastrophic failures like an internal thread terminating because 
# of an exception or getting stuck in a deadlock condition. Events like these will make the stack 
# inoperable and therefore require immediate action from the application layer (e.g., alarms, traps, 
# reboot, failover, etc.) Thread audits are disabled by default. If this property is not specified, 
# audits will remain disabled. An example of how to use this property is in src/examples/threadaudit. 
# type long (in milliseconds)
# [string] 
gov.nist.javax.sip.THREAD_AUDIT_INTERVAL_IN_MILLISECS = 3600000

# XMLLoader internal routing parameters
# [string] 
SIP_INTERNAL_REQUEST_ROUTING_PARAMETER = Route\:uri\:id

# receive tag timeout value in seconds, 0 = infinite
# [string] 
SIP_RECEIVE_TIMEOUT_VALUE = 30

