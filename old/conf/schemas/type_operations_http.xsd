<!--                                                                       START OF HTTP PROTOCOL -->

<!--                                                                          openChannel -->
<xs:complexType name="openChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="localHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localPort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteURL"      type="xs:string" use="required" />
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         closeChannel -->
<xs:complexType name="closeChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

<!--                                                                               sendMessage -->
<xs:complexType name="sendMessageHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteURL" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destScenario" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (scenario name)</xs:appinfo>
                    <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delay" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transactionId"  type="xs:string">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                            receiveMessage -->
<xs:complexType name="receiveMessageHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                          openConnectionHTTP -->
<xs:complexType name="openConnectionHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="connectionName" type="xs:string" use="required" />
            <xs:attribute name="localPort"      type="xs:string" />
            <xs:attribute name="localHost"      type="xs:string" />
            <xs:attribute name="remoteURL"      type="xs:string" use="required" />
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         closeConnectionHTTP -->
<xs:complexType name="closeConnectionHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType" >
            <xs:attribute name="connectionName" type="xs:string" use="required" />
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                              sendRequestHTTP -->
<xs:complexType name="sendRequestHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="connectionName" type="xs:string" />
            <xs:attribute name="server"       type="xs:string" />
            <xs:attribute name="destScenario" type="xs:string" />
            <xs:attribute name="delay"         type="xs:string" />
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                               sendResponseHTTP -->
<xs:complexType name="sendResponseHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="transactionId" type="xs:string" use="required"/>
            <xs:attribute name="delay"         type="xs:string" />
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                           receiveRequestHTTP -->
<xs:complexType name="receiveRequestHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="timeout"      type="xs:string" />
            <xs:attribute name="method"       type="xs:string" />
            <xs:attribute name="failedOnTimeout"    type="xs:string" />
            <xs:attribute name="failedOnReceive"    type="xs:string" />
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                            receiveResponseHTTP -->
<xs:complexType name="receiveResponseHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="timeout"      type="xs:string" />
            <xs:attribute name="method"       type="xs:string" />
            <xs:attribute name="result"       type="xs:string" />
            <xs:attribute name="failedOnTimeout"    type="xs:string" />
            <xs:attribute name="failedOnReceive"    type="xs:string" />
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         END OF HTTP PROTOCOL -->
